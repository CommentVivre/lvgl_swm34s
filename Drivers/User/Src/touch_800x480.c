/***
	************************************************************************************************************************************************************************************************
	*	@version V1.0
	*  @date    2023-4-3
	*	@author  反客科技	
   **********************************************************************************************************************************************************************************************
   *  @description
	*
	*	实验平台：反客 SWM34SVET6 核心板 （型号：FK-SWM34SVE-M1）+ 反客800*480分辨率的RGB屏幕
	*	淘宝地址：https://shop212360197.taobao.com
	*	QQ交流群：536665479
	*
>>>>> 文件说明：
	*
	*  1.触摸屏相关的操作函数
	* 	2.实际使用的触摸IC为GT911系列
	*	3.通信速度默认为300KHz
	*	
	*********************************************************************************************************************************************************************************************FANKE*****
***/


#include "uart.h"

volatile TouchStructure touchInfo; 			//	触摸信息结构体，在函数 Touch_Scan() 里被调用，存储触摸数据


/*************************************************************************************************************************************
*	函 数 名:	Touch_IIC_Config
*	
*	函数功能:	初始化IIC引脚、配置等
*	
************************************************************************************************************************************/

void Touch_IIC_Config(void) 	
{
	I2C_InitStructure I2C_initStruct;

	PORT_Init(PORTA, PIN1, PORTA_PIN1_I2C0_SCL, 1); 					// 配置为I2C0 SCL引脚
	Touch_IIC_SCL_PORT->OPEND |= (1 << PORTA_PIN1_I2C0_SCL);
	Touch_IIC_SCL_PORT->PULLU |= (1 << PORTA_PIN1_I2C0_SCL);         //必须使能上拉，用于模拟开漏

	PORT_Init(Touch_IIC_SDA_PORT, PIN0, PORTA_PIN0_I2C0_SDA, 1); 	// 配置为I2C0 SDA引脚
	Touch_IIC_SDA_PORT->OPEND |= (1 << PORTA_PIN0_I2C0_SDA);
	Touch_IIC_SDA_PORT->PULLU |= (1 << PORTA_PIN0_I2C0_SDA); 		//必须使能上拉，用于模拟开漏

	I2C_initStruct.Master 			= 1;				// 主机模式
	I2C_initStruct.MstClk 			= 300000;		// I2C速度300KHz
	I2C_initStruct.Addr10b 			= 0;				// 7位地址模式
	I2C_initStruct.TXEmptyIEn 		= 0;				// 不使用 发送寄存器空中断
	I2C_initStruct.RXNotEmptyIEn 	= 0;				// 不使用 接收寄存器非空中断
	I2C_Init(I2C0, &I2C_initStruct);
	
	I2C_Close(I2C0);		// 一些关键寄存器只能在I2C关闭时设置	
	
// 因为实际触摸屏都是和RGB信号共用一根排线，因此触摸的数据线信号质量不会很好，
// 使用MCU自带的数字噪声滤波功能，会使触摸屏的工作更加稳定	
	I2C0->CR |= 0x56;		// 设置SCL、SDA滤波参数，此处设置为 7个系统时钟
	
	I2C_Open(I2C0);	// 使能I2C

	GPIO_Init(Touch_INT_PORT, Touch_INT_PIN, 1, 1, 0, 0); // INT引脚，设置推挽输出，上拉
	GPIO_Init(Touch_RST_PORT, Touch_RST_PIN, 1, 1, 0, 0); // RST引脚，设置推挽输出，上拉		

}


/*************************************************************************************************************************************
*	函 数 名: Touch_IIC_INT_Out
*	
*	函数功能: 配置IIC的INT脚为输出模式
*	
************************************************************************************************************************************/

void Touch_INT_Out(void)
{
	GPIO_Init(Touch_INT_PORT, Touch_INT_PIN, 1, 1, 0, 0); // INT引脚，设置推挽输出，上拉
}

/*************************************************************************************************************************************
*	函 数 名: Touch_IIC_INT_In
*	
*	函数功能: 配置IIC的INT脚为输入模式
*	
************************************************************************************************************************************/

void Touch_INT_In(void)
{	
	GPIO_Init(Touch_INT_PORT, Touch_INT_PIN, 0, 0, 0, 0); // INT引脚， 输入模式、禁止上拉、禁止下拉、推挽	
}

/*************************************************************************************************************************************
*	函 数 名:	GT9XX_WriteHandle
*	入口参数:	addr - 要操作的寄存器
*	返 回 值:	ACK_OK - 操作成功  、  ERROR	  - 操作失败			
*	函数功能:	GT9XX 写操作
*	说    明:对指定的寄存器执行写操作
************************************************************************************************************************************/

uint8_t GT9XX_WriteHandle (uint16_t addr)
{
   uint8_t ack;
	uint32_t i;
	
	if( I2C_Start(I2C0, GT9XX_IIC_WADDR , 1) == ACK_OK ) //启动IIC通信,写数据指令
	{
		if( I2C_Write(I2C0,(uint8_t)(addr >> 8),1) == ACK_OK ) //写入16位地址
		{
			if( I2C_Write(I2C0,(uint8_t)addr,1) != ACK_OK )
			{
				I2C_Stop(I2C0, 1); // 停止通讯		
				
				/* 参考华芯微特官方的例程，加入短暂延时，实际测试如果不加这段延时，在大批连续写数据时可能会出错*/		
				for (i = 0; i < CyclesPerUs; i++)
				__NOP();	
				
				return ACK_ERR;	// 操作失败
			}			
		}
	}
	return ACK_OK;	
}


/*************************************************************************************************************************************
*	函 数 名:	GT9XX_WriteData
*	入口参数:	addr - 要写入的寄存器
*				value - 要写入的数据
*	返 回 值:	ACK_OK - 操作成功  、  ERROR	  - 操作失败		
*	函数功能:	GT9XX 写一字节数据
*	说    明:对指定的寄存器写入一字节数据
************************************************************************************************************************************/

uint8_t GT9XX_WriteData (uint16_t addr,uint8_t value)
{
	uint8_t status;
	uint32_t i;
	
	if( GT9XX_WriteHandle(addr) == ACK_OK )	//写入要操作的寄存器
	{
		if ( I2C_Write(I2C0,value,1) != ACK_OK) //写数据
		{
			status =  ACK_ERR;	// 操作失败						
		}
	}	
	
	I2C_Stop(I2C0, 1); // 停止通讯
	
	/* 参考华芯微特官方的例程，加入短暂延时，实际测试如果不加这段延时，在大批连续写数据时可能会出错*/		
	for (i = 0; i < CyclesPerUs; i++)
	__NOP();	
	
	status = ACK_OK;
	return status;	// 写入成功
}

/*************************************************************************************************************************************
*	函 数 名:	GT9XX_ReadReg
*	入口参数:	addr - 要读取的寄存器区域首地址
*				cnt  - 数据长度
*				value - 要读取的数据区
*	返 回 值:	ACK_OK - 操作成功  、  ERROR	  - 操作失败		
*	函数功能:	GT9XX 读寄存器
*	说    明:从芯片的寄存器区读取指定长度的数据
************************************************************************************************************************************/

uint8_t GT9XX_ReadBuff (uint16_t addr, uint8_t cnt, uint8_t *value)
{
	uint8_t status;
	uint32_t i;

	status = ACK_ERR;
	
	if( GT9XX_WriteHandle(addr) == ACK_OK ) //写入要操作的寄存器
	{	
		/* 参考华芯微特官方的例程，加入短暂延时，实际测试如果不加这段延时，在大批连续读取数据时可能会出错*/		
		 for (i = 0; i < CyclesPerUs; i++)
        __NOP();
		
		if ( I2C_Start(I2C0,GT9XX_IIC_RADDR,1) == ACK_OK )	// 发送读命令
		{	
			for (i = 0; i < cnt - 1; i++)
			{
				value[i] = I2C_Read(I2C0, 1, 1);// 发送应答信号
			}
			value[i] = I2C_Read(I2C0, 0, 1);// 读到最后一个数据时发送 非应答信号
			
			status = ACK_OK;
		}
	}
	
	I2C_Stop(I2C0, 1); // 停止通讯
	
	/* 参考华芯微特官方的例程，加入短暂延时，实际测试如果不加这段延时，在大批连续读取数据时可能会出错*/		
	for (i = 0; i < CyclesPerUs; i++)
	__NOP();
	
	return (status);	
}




/*************************************************************************************************************************************
*	函 数 名:	GT9XX_Reset
*	
*	函数功能:	复位GT911，并将芯片的IIC地址配置为0xBA/0xBB
*	
************************************************************************************************************************************/

void GT9XX_Reset(void)
{
	Touch_INT_Out();	//	将INT引脚配置为输出
	
	Touch_INT_L;		// INT输出低电平
	Touch_RST_H;		// RST输出高	电平
	osDelay(5);

	// 开始执行复位
	//	INT引脚保持低电平不变，将器件地址设置为0XBA/0XBB
	Touch_RST_L; 			// 拉低复位引脚，此时芯片执行复位
	osDelay(10);			// 延时
	Touch_RST_H;			// 拉高复位引脚，复位结束
	osDelay(10);			// 延时
	
	Touch_INT_In();			// INT引脚转为浮空输入
	osDelay(50);				// 延时,等待复位结束
								
}

/*************************************************************************************************************************************
*	函 数 名: Touch_Init
*
*	函数功能: 触摸IC初始化，并读取相应信息发送到串口
*	
************************************************************************************************************************************/

void Touch_Init(void)
{
	uint8_t GT9XX_Info[11];	// 触摸屏IC信息
	uint8_t cfgVersion = 0;	// 触摸配置版本

	Touch_IIC_Config(); 	// 初始化IIC引脚、配置等
	GT9XX_Reset();			// 复位触摸IC

	GT9XX_ReadBuff (GT9XX_ID_ADDR,11,GT9XX_Info);		// 读触摸屏IC信息
	GT9XX_ReadBuff (GT9XX_CFG_ADDR,1,&cfgVersion);	// 读触摸配置版本
	
	if( GT9XX_Info[0] == '9' )	//判断第一个字符是否为 9
	{
		#if 0
		printf("Touch ID: GT%.4s \r\n",GT9XX_Info);	//打印触摸芯片的ID
		printf("固件版本： 0X%.4x\r\n",(GT9XX_Info[5]<<8) + GT9XX_Info[4]);	// 芯片固件版本
		printf("触摸分辨率：%d * %d\r\n",(GT9XX_Info[7]<<8) + GT9XX_Info[6],(GT9XX_Info[9]<<8) +GT9XX_Info[8]);	// 当前触摸分辨率		
		printf("触摸参数配置版本： 0X%.2x \r\n",cfgVersion);	// 触摸配置版本	
		// 中断触摸配置
		EXTI_Init(Touch_INT_PORT, Touch_INT_PIN, EXTI_FALL_EDGE);
		NVIC_EnableIRQ(GPIOD_IRQn);
		EXTI_Open(GPIOA, PIN0);
		GT9XX_WriteData(0x804D,0x00);
		#endif
	}
	else
	{
		printf("Touch Error\r\n");	//错误，未检测到触摸屏
	}
}



/*************************************************************************************************************************************
*	函 数 名: Touch_Scan
*	入口参数: 无
*	返 回 值: 无
*	函数功能: 触摸扫描
*	说    明: 在程序里周期性的调用该函数，用以检测触摸操作，触摸信息存储在 touchInfo 结构体
************************************************************************************************************************************/

void Touch_Scan(void)
{
 	uint8_t  touchData[2 + 8 * TOUCH_MAX ]; 		// 用于存储触摸数据
	uint8_t  i = 0;	
	 
	GT9XX_ReadBuff (GT9XX_READ_ADDR,2 + 8 * TOUCH_MAX ,touchData);	// 读数据
	GT9XX_WriteData (GT9XX_READ_ADDR,0);		//	清除触摸芯片的寄存器标志位
	
	touchInfo.num = touchData[0] & 0x0f;									// 取当前的触摸点数
	
	if ( (touchInfo.num >= 1) && (touchInfo.num <=5) ) 	//	当触摸数在 1-5 之间时
	{
		for(i=0;i<touchInfo.num;i++)		// 取相应的触摸坐标
		{
			touchInfo.y[i] = (touchData[5+8*i]<<8) | touchData[4+8*i];	// 获取Y坐标
			touchInfo.x[i] = (touchData[3+8*i]<<8) | touchData[2+8*i];	//	获取X坐标	
		}
		touchInfo.flag = 1;	// 触摸标志位置1，代表有触摸动作发生
	}
	else                       
	{
		touchInfo.flag = 0;	// 触摸标志位置0，无触摸动作
	}
}

